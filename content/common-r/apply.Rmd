---
title: "R apply family, sweep, map, reduce, filter"
weight: 2
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R apply family

The apply family of functions consist of `apply()`, `lapply()`, `sapply()`, and `mapply()`. The basic idea of the apply family is to apply the same function repetitively across a list or a certain dimension of an array or dataframe.

### apply

We start with `apply()`. Its syntax is `apply(X, MARGIN, FUN, ...)`, where

- `X` is an array, including a matrix.
- `MARGIN` is a vector giving the subscripts which the function will be applied over. For example, for a matrix 1 indicates rows (i.e. output has length equal to number of rows), 2 indicates columns (i.e. output has length equal to number of columns), `c(1, 2)` indicates rows and columns (i.e. output remains a matrix of the same dimension).
- `FUN` is the function to be applied

As an example, we construct a matrix of all 1's and sum across rows and columns:

```{r}
x = matrix(1, nrow=3, ncol=4)
apply(x, 1, sum)
apply(x, 2, sum)
apply(x, c(1,2), sum)
```

The function can be defined by the user. For example,

```{r}
apply(x, 1, function(x) sum(exp(x)))
```

The input can also be a higher dimensional array

```{r}
apply(array(1, dim=c(2,3,4)), c(1,2), sum)
```

### lapply

In contrast to `apply`, which must be applied to data of higher than one dimension, `lapply` applies a function over a list or vector and outputs a list. Its basic usage is `lapply(X, FUN, ...)`. For example,

```{r}
lapply(rep(1,5), exp)
x = list(a=1:10, b=exp(-3:3), c=c(TRUE,FALSE,FALSE,TRUE))
lapply(x, mean)
lapply(x, quantile, probs=(1:3)/4)
```

### sapply

The `sapply()` function works like `lapply()`, but it tries to simplify the output as much as possible.

```{r}
sapply(rep(1,5), exp)
unlist(lapply(rep(1,5), exp))
sapply(x, mean)
sapply(x, quantile, probs=(1:3)/4)
```

### mapply
`mapply` is a multivariate version of `sapply`. It is useful if you have more than one input to the function. Its basic usage is `mapply(FUN, ...,)`, where ... stands for the inputs to `FUN`. Notice that the order of parameters is in a different order to `apply` or `lapply`. (Why?)

```{r}
mapply(rep, 1:4, 4:1)
mapply(rep, times = 1:4, x = 4:1)
mapply(function(x, y) seq_len(x) + y, c(a=1, b=2, c=3), c(A=10, B=0, C=-10))
```

### Speed vs for loop
To compare the performance of a piece of code written using apply vs foor loop, we use the following simple function

```{r}
ftest1 = function(x) log(0.43 * x + 1)
x = 1:1e6 #runif(1e+06, min = -1, max = 1)
ftest1_apply = function(x) sapply(x, ftest1)
ftest1_loop = function(x) {
  y = rep(NA, length(x))
  for (i in 1:length(x)) y[i] = ftest1(x[i])
  y
}
system.time(ftest1_apply(x))
system.time(ftest1_loop(x))
system.time(ftest1(x))
```
The results show that sapply is the slowest, with for loop being twice as fast as sapply. But obviously applying the function directly (hence vectorized) is the fastest by far.

## Map, Reduce and Filter

First, a word on the lambda notation, which is a short, typically one-line, definition of a function:
`{function add1(x, y) x+y}`. Note that this alone makes no sense in R. It has to be used in Map, Reduce or Filter. Note also that the first letter of these functions are capped.

### Map

The function `Map` maps the same function to every element in a vector. For example,

```{r}
x = 1:6
y = Map({function(a) a*a}, x)
y
unlist(y)
```

### Reduce

The function `Reduce` will perform the function on pairs of elements of a vector, iterate the procedure, and return a single number. For example,

```{r}
Reduce(function(a, b) a+b, x)
Reduce(function(x, y) x*y, x)
```

Note that in the last line, `x` and `y` in the lambda definition of the function is internal to the function itself and has no meaning outside.

### Filter

The function `Filter` goes down a vector and only keep elements that satisfies the condition determined by the function. For example,

```{r}
Filter(function(x) x%%2==0, x)
Filter(function(x) x>3, x)
Filter(function(x) x-1, x)
```

Note that in R, 0 is treated as `FALSE`, whereas any non-zero number is treated as `TRUE`
