<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>2. RcppArmadillo - SC2</title>
    <meta property="og:title" content="2. RcppArmadillo - SC2">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="Many standard statistical models/algorithms (e.g., linear regression, principal component analysis, …) require using numerical linear algebra routines, hence this section explains how to perform such &amp;hellip;">
      <meta property="og:description" content="Many standard statistical models/algorithms (e.g., linear regression, principal component analysis, …) require using numerical linear algebra routines, hence this section explains how to perform such &amp;hellip;">
      
    

    
    

    

    
    


<link href='//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



    <link rel="stylesheet" href="/sc2-2019/css/style.css" />
    <link rel="stylesheet" href="/sc2-2019/css/fonts.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Arvo">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Marcellus">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">

<link rel="stylesheet" href="/sc2-2019/css/custom.css" />

<link rel="icon" href="/sc1-2019/favicon.ico" type="image/x-icon" />























<nav class="breadcrumbs">
    
        <a href="https://mfasiolo.github.io/sc2-2019/">home / </a>
    
        <a href="https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/">rcpp_advanced_i / </a>
    
        <a href="https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/2_rcpparmadillo/">2_rcpparmadillo / </a>
    
</nav>

  </head>

  
  <body class="sc2-2019">
    <header class="masthead">
      <h1><a href="/sc2-2019/">SC2</a></h1>

<p class="tagline">Statistical Computing 2</p>

      <nav class="menu">
  <input id="menu-check" type="checkbox" />
  <label id="menu-label" for="menu-check" class="unselectable">
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li><a href="/sc2-2019/">Home</a></li>
  
  <li><a href="/sc2-2019/rcpp/">Integrating R and C</a></li>
  
  <li><a href="/sc2-2019/rcpp_advanced_i/">Advanced Rcpp I</a></li>
  
  <li><a href="/sc2-2019/rcpp_advanced_ii/">Advanced Rcpp II</a></li>
  
  <li><a href="/sc2-2019/rcpp_advanced_iii/">Parallel Rcpp</a></li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>2. RcppArmadillo</h1>

<h3>
</h3>
<hr>


      </header>





<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#motivating-example-1-matrix-matrix-vector-product">Motivating example 1: matrix-matrix-vector product</a></li>
<li><a href="#motivating-example-2-sums-of-matrices">Motivating example 2: sums of matrices</a></li>
<li><a href="#basic-rcpparmadillo-usage">Basic <code>RcppArmadillo</code> usage</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<style>
body {
text-align: justify}
</style>
<div id="introduction" class="section level3">
<h3>Introduction</h3>
<p>Many standard statistical models/algorithms (e.g., linear regression, principal component analysis, …) require using numerical linear algebra routines, hence this section explains how to perform such computations efficiently using the <code>RcppArmadillo</code> <code>R</code> package. <code>RcppArmadillo</code> provides an interface to the <code>Armadillo</code> <code>C++</code> numerical linear algebra library, which is highly useful in practice because it provides an interesting balance between performance and ease of use. The syntax of <code>Armadillo</code> resembles that of <code>Matlab</code>, which is not too different from <code>R</code>’s syntax. Part of the performance speed-ups of <code>Armadillo</code>, relative to base <code>R</code>, are obtained via automatic pooling of several linear algebra operations into one at compile-time.</p>
</div>
<div id="motivating-example-1-matrix-matrix-vector-product" class="section level3">
<h3>Motivating example 1: matrix-matrix-vector product</h3>
<p>To demostrate the capabilities of <code>Armadillo</code>, we start by considering a simple example on matrix multiplication. In particular, consider computing the product <span class="math inline">\({\bf A} {\bf B} {\bf y}\)</span> where <span class="math inline">\({\bf A}\)</span> and <span class="math inline">\({\bf B}\)</span> are <span class="math inline">\(d \times d\)</span> matrices and <span class="math inline">\(y\)</span> is a <span class="math inline">\(d\)</span>-dimensional vector. In <code>R</code> we would compute the product simply by doing <code>A%*%B%*%y</code>. Could we get some speed-ups by using <code>Rcpp</code>? To verify this, we <strong>try</strong> to create a function that computes the matrix-matrix-vector product in <code>Rcpp</code>:</p>
<pre class="r"><code>library(Rcpp)
sourceCpp(code = &#39;
 #include &lt;Rcpp.h&gt;
 using namespace Rcpp;

 // [[Rcpp::export(name = &quot;MMv_wrong&quot;)]]
 NumericVector MMv_I(NumericMatrix A, NumericMatrix B, NumericVector y) {
   return A * B * y;
 }&#39;
)</code></pre>
<p>The problem with this function is that it is not equivalent to <code>A%*%B%*%y</code>. In fact, it does not computes <code>A%*%B%*%y</code>, but something quite different:</p>
<pre class="r"><code>d &lt;- 3
A &lt;- matrix(1, d, d)
B &lt;- matrix(1, d, d)
y &lt;- 1:d

MMv_wrong(A, B, y)</code></pre>
<pre><code>## [1]  1.000000e+00  2.000000e+00  3.000000e+00 2.105418e-314 2.917744e-314
## [6] 4.664236e-310 4.664239e-310 4.664239e-310 1.482197e-323</code></pre>
<p>In particular, <code>A * B</code> in <code>MMv_I</code> is equivalent to <code>as.vector(A * B)</code> is <code>R</code>, that is it computes the element-wise product of two matrices and then converts the output to a vector. Then one might expect that <code>A * B * y</code> in <code>MMv_I</code> should be equivalent to:</p>
<pre class="r"><code>as.vector(A * B) * y</code></pre>
<pre><code>## [1] 1 2 3 1 2 3 1 2 3</code></pre>
<p>in <code>R</code>, but this is also wrong because, when multiplying vectors of different length, <code>Rcpp</code> does not perform the recycling as <code>R</code> does. For example:</p>
<pre class="r"><code>addDiffLengh &lt;- cppFunction(&quot;
 NumericVector addDiffLengh(NumericVector x1, NumericVector x2) {
     return x1 + x2;
}&quot;)
addDiffLengh(1:3, 1)</code></pre>
<pre><code>## [1] 2 2 3</code></pre>
<pre class="r"><code>addDiffLengh(1, 1:3)</code></pre>
<pre><code>## [1] 2</code></pre>
<p>does not behave in the way we would expect in <code>R</code>. In the first case we are adding <code>1</code> to the vector <code>1:3</code>, and the output shows that no recycling in going on (compare this with <span class="math inline">\(1:3 + 1\)</span> in <code>R</code>). In the second case, we are adding <code>1:3</code> to a vector of length <code>1</code> and <code>Rcpp</code> does not do any recycling either.</p>
<p>The bottom line is that we should not expect <code>Rcpp</code> code to behave like <code>R</code> code when it comes to recycling, and that <code>Rcpp</code> does not provide a direct equivalent of the <code>%*%</code> operator for matrix-matrix and matrix-vector multiplication. Hence, when doing linear algebra in <code>Rcpp</code>, we are better off using the methods offered by the <code>RcppArmadillo</code> package, as done in the following function:</p>
<pre class="r"><code>sourceCpp(code = &#39;
 // [[Rcpp::depends(RcppArmadillo)]]
 #include &lt;RcppArmadillo.h&gt;
 using namespace Rcpp;

 // [[Rcpp::export(name = &quot;MMv_arma&quot;)]]
 arma::vec MMv_arma_I(arma::mat&amp; A, arma::mat&amp; B, arma::vec&amp; y) {
   return A * B * y;
}&#39;, verbose = TRUE)</code></pre>
<pre><code>## 
## Generated extern &quot;C&quot; functions 
## --------------------------------------------------------
## 
## 
## #include &lt;Rcpp.h&gt;
## #ifdef RCPP_USE_GLOBAL_ROSTREAM
## Rcpp::Rostream&lt;true&gt;&amp;  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
## Rcpp::Rostream&lt;false&gt;&amp; Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
## #endif
## 
## // MMv_arma_I
## arma::vec MMv_arma_I(arma::mat&amp; A, arma::mat&amp; B, arma::vec&amp; y);
## RcppExport SEXP sourceCpp_5_MMv_arma_I(SEXP ASEXP, SEXP BSEXP, SEXP ySEXP) {
## BEGIN_RCPP
##     Rcpp::RObject rcpp_result_gen;
##     Rcpp::RNGScope rcpp_rngScope_gen;
##     Rcpp::traits::input_parameter&lt; arma::mat&amp; &gt;::type A(ASEXP);
##     Rcpp::traits::input_parameter&lt; arma::mat&amp; &gt;::type B(BSEXP);
##     Rcpp::traits::input_parameter&lt; arma::vec&amp; &gt;::type y(ySEXP);
##     rcpp_result_gen = Rcpp::wrap(MMv_arma_I(A, B, y));
##     return rcpp_result_gen;
## END_RCPP
## }
## 
## Generated R functions 
## -------------------------------------------------------
## 
## `.sourceCpp_5_DLLInfo` &lt;- dyn.load(&#39;/tmp/RtmpQsvTBS/sourceCpp-x86_64-pc-linux-gnu-1.0.8/sourcecpp_ed0d2abe7b29/sourceCpp_6.so&#39;)
## 
## MMv_arma &lt;- Rcpp:::sourceCppFunction(function(A, B, y) {}, FALSE, `.sourceCpp_5_DLLInfo`, &#39;sourceCpp_5_MMv_arma_I&#39;)
## 
## rm(`.sourceCpp_5_DLLInfo`)
## 
## Building shared library
## --------------------------------------------------------
## 
## DIR: /tmp/RtmpQsvTBS/sourceCpp-x86_64-pc-linux-gnu-1.0.8/sourcecpp_ed0d2abe7b29
## 
## /opt/R/4.1.2/lib/R/bin/R CMD SHLIB -o &#39;sourceCpp_6.so&#39; &#39;fileed0d3e6b70f6.cpp&#39;</code></pre>
<p>Before illustrating the performance of this function, let’s explain what is going on in the code above:</p>
<ul>
<li><code>// [[Rcpp::depends(RcppArmadillo)]]</code> is an <code>Rcpp</code> attribute that states that our code depends on the <code>RcppArmadillo</code>
package. The attribute makes so that <code>sourceCpp</code> will configure the build environment to compile and link against
the <code>RcppArmadillo</code> package.</li>
<li><code>#include &lt;RcppArmadillo.h&gt;</code> includes the code from <code>RcppArmadillo</code>, note that we don’t need to include <code>Rcpp.h</code>
as well.</li>
<li><code>arma::mat</code> and <code>arma::vec</code> indicate matrices and vectors of doubles defined in the <code>arma</code> namespace of the
the <code>Armadillo</code> library. Here these are passed by reference using <code>arma::mat&amp;</code> and <code>arma::vec&amp;</code>,
hence no copy is produced. From the text output of <code>sourceCpp</code> we see that the original <code>SEXP</code> objects
are converted to <code>arma::mat</code> objects via the <code>Rcpp::traits::input_parameter</code> mechanism.
The latter is beyond the scope of this course, but the point is that the conversion
from <code>R</code> to <code>arma</code> objects is handled automatically by <code>RcppArmadillo</code>. Conversions in the opposite direction
are handled via <code>Rcpp::wrap</code>.</li>
</ul>
<p>Let us now compare our <code>Armadillo</code> implementation with the plain <code>R</code> version:</p>
<pre class="r"><code>d &lt;- 1e3
A &lt;- matrix(rnorm(d^2), d, d)
B &lt;- matrix(rnorm(d^2), d, d)
y &lt;- rnorm(d)

max(abs(A %*% B %*% y - MMv_arma(A, B, y)))</code></pre>
<pre><code>## [1] 1.023182e-11</code></pre>
<pre class="r"><code>library(microbenchmark)
microbenchmark(R = A %*% B %*% y, 
               Arma = MMv_arma(A, B, y))</code></pre>
<pre><code>## Unit: milliseconds
##  expr      min       lq       mean   median        uq      max neval
##     R 690.1498 690.7926 692.050254 691.4437 693.11270 698.2469   100
##  Arma   1.3756   1.8204   1.834679   1.8797   1.90745   3.2796   100</code></pre>
<p>The performance gains are substantial! It might be tempting to conclude that the <code>Armadillo</code> library is just so much better than <code>R</code> default linear algebra routines, but we need to understand how this performance gain was achieved. To do so, consider the following comparison:</p>
<pre class="r"><code>microbenchmark(R = A %*% (B %*% y), 
               Arma = MMv_arma(A, B, y))</code></pre>
<pre><code>## Unit: milliseconds
##  expr    min      lq     mean  median      uq    max neval
##     R 2.1494 2.16065 2.190219 2.17265 2.18850 3.0626   100
##  Arma 1.3749 1.38075 1.400111 1.38520 1.39215 2.3541   100</code></pre>
<p>It seems that simply adding a pair of brackets made our <code>R</code> code much more efficient, and closer to <code>Armadillo</code>’s performance! The reason is simply that the code <code>A %*% B %*% y</code> computes the matrix product first, which is a <span class="math inline">\(O(d^3)\)</span> operation, and then multiplies that resulting matrix by the vector <code>y</code>, which is a <span class="math inline">\(O(d^2)\)</span> operation. Instead, <code>A %*% (B %*% y)</code> computes two matrix-vector multiplications, thus avoiding the <span class="math inline">\(O(d^3)\)</span> computation. The question is whether the speed-up we are getting from <code>Armadillo</code> is due to the fact that this library is automatically computing the matrix-matrix-vector product using this more efficient order of operations. To verify this, we write the following:</p>
<pre class="r"><code>sourceCpp(code = &#39;
 // [[Rcpp::depends(RcppArmadillo)]]
 #include &lt;RcppArmadillo.h&gt;
 using namespace Rcpp;

 // [[Rcpp::export(name = &quot;MMv_arma_slow&quot;)]]
 arma::vec MMv_arma_I(arma::mat&amp; A, arma::mat&amp; B, arma::vec&amp; y) {
   arma::mat C = A * B;
   return C * y;
}&#39;)</code></pre>
<p>And we compare it with the inefficient <code>R</code> implementation:</p>
<pre class="r"><code>microbenchmark(R = A %*% B %*% y,
               Arma_slow = MMv_arma_slow(A, B, y))</code></pre>
<pre><code>## Unit: milliseconds
##       expr      min       lq     mean   median       uq      max neval
##          R 687.0554 688.0565 690.4226 690.4042 692.4400 694.8131   100
##  Arma_slow 684.7952 685.5135 687.0807 687.8242 688.4507 689.4727   100</code></pre>
<p>Now the performance is comparable, hence the efficiency of the <code>Armadillo</code> implementation is mostly due to the order in which the computations are performed. The fact that we can achieve similar performance using base <code>R</code> and a pair of (well-placed) brackets might be disappointing, but note that it is remarkable that <code>Armadillo</code> is able to automatically determine the order of operations so as to optimize efficiency. In reality, <code>Armadillo</code> does more than just reordering operation, but it can combine several operations into one and reduce the need for temporary objects, via delayed evaluation. This can result in faster computation and lower memory usage, relative to naive evaluation. Delayed evaluation is achieved via template meta-programming, which is beyond the scope of this course. From a user point of view, what matters is that template meta-programming allows <code>Armadillo</code> to reason about linear algebra expression at compile-time, with the aim of producing code that is tailored to each mathematical expression. See <code>Armadillo</code>’s <a href="http://arma.sourceforge.net/">website</a> for more details.</p>
<p>Before describing some of the main functions and structures provide by <code>Armadillo</code> and <code>RcppArmadillo</code>, we cover another basic example in the next section.</p>
</div>
<div id="motivating-example-2-sums-of-matrices" class="section level3">
<h3>Motivating example 2: sums of matrices</h3>
<p>In the previous section we considered the <code>R</code> code <code>A %*% B %*% y</code> and we showed how it can be made much more efficient simply by writing it as <code>A %*% (B %*% y)</code>. Here we consider a simple linear algebra example, where improving the efficiency of a base <code>R</code> implementation is not straightforward. In particular, consider calculating <span class="math inline">\({\bf A} + {\bf B} + {\bf C} + {\bf D} + {\bf E}\)</span>, where <span class="math inline">\({\bf A}, \dots, {\bf E}\)</span> are <span class="math inline">\(d \times d\)</span> matrices (the shape of the matrices is not important). A simple <code>Armadillo</code> function for computing such a sum is:</p>
<pre class="r"><code>sourceCpp(code = &#39;
// [[Rcpp::depends(RcppArmadillo)]]
#include &lt;RcppArmadillo.h&gt;
using namespace arma;

// [[Rcpp::export(name = &quot;mSum_arma&quot;)]]
mat mSum_i(mat&amp; A, mat&amp; B, mat&amp; C, mat&amp; D, mat&amp; E) {
  return A + B + C + D + E;
}&#39;)</code></pre>
<p>Let us compare it with with plain <code>R</code> code:</p>
<pre class="r"><code>A &lt;- B &lt;- C &lt;- D &lt;- E &lt;- matrix(rnorm(1e6), 1e3, 1e3)

microbenchmark(R = Z &lt;- A + B + C + D + E,
               arma = Z &lt;- mSum_arma(A, B, C, D, E))</code></pre>
<pre><code>## Unit: milliseconds
##  expr    min     lq      mean  median       uq     max neval
##     R 7.6640 9.7794 18.453778 11.6424 13.43220 64.7152   100
##  arma 2.4289 3.5335  7.668486  5.1232  7.21775 57.9725   100</code></pre>
<p>As we might have expected, the <code>Armadillo</code> version of the sum is faster. How was this better performance achieved? Note that when evaluating the <code>A + B + C + D + E</code>, <code>R</code> will compute <code>A + B</code> and store the result in a temporary object, which we call <code>ApB</code>. Then, it will compute <code>ApB + C</code> and store the temporary result in another matrix, and so on. Hence, the four matrix sums will result in the allocation of four matrices, three of these are temporary and will be discarded, the last one will be stored as <code>Z</code>. An efficient implementation would avoid allocating memory for three temporary matrices, but would simply allocate memory for <code>Z</code> and then do:</p>
<pre class="r"><code>for(i in 1:d)
  for(j in 1:d)
    Z[i, j] &lt;- A[i, j] + B[i, j] + C[i, j] + D[i, j] + E[i, j]  </code></pre>
<p>but doing few floating point operations within a nested loop is of course hopelessly inefficient in <code>R</code>. The question is whether <code>Armadillo</code> has been able to work out that this is the best way of framing of computation. To investigate whether the performance of <code>Armadillo</code> could be attributed to such compile-time optimization, we write a version of <code>mSum_arma</code> which explicitly creates temporary matrices:</p>
<pre class="r"><code>sourceCpp(code = &#39;
// [[Rcpp::depends(RcppArmadillo)]]
#include &lt;RcppArmadillo.h&gt;
using namespace arma;

// [[Rcpp::export(name = &quot;mSum_arma_slow&quot;)]]
mat mSum_i(mat&amp; A, mat&amp; B, mat&amp; C, mat&amp; D, mat&amp; E) {
  mat T1 = A + B;
  mat T2 = T1 + C;
  mat T3 = T2 + D;
  return T3 + E;
}&#39;)</code></pre>
<p>We then add this version to the comparison:</p>
<pre class="r"><code>microbenchmark(R = Z &lt;- A + B + C + D + E,
               arma = Z &lt;- mSum_arma(A, B, C, D, E), 
               arma_slow = Z &lt;- mSum_arma_slow(A, B, C, D, E))</code></pre>
<pre><code>## Unit: milliseconds
##       expr    min      lq      mean   median       uq     max neval
##          R 7.5279  9.6285 18.371974 11.16735 12.93335 66.0941   100
##       arma 2.4424  3.4729  6.777844  4.76835  6.13790 56.2528   100
##  arma_slow 8.0517 10.1691 14.091081 13.38605 15.90060 65.7938   100</code></pre>
<p>The performance of the second <code>Armadillo</code> version is close to that of the <code>R</code> code, hence we can conclude that the efficiency of the first <code>Armadillo</code> version is attributable to the fact that it avoids creating temporary matrices.</p>
<p>To conclude this example, consider its extension to the problem of computing <span class="math inline">\({\bf A} + {\bf B} + \cdots\)</span>, where the number of matrices involved in the sum is arbitrary (that is, not fixed to five as above). If the matrices are contained in a <code>list</code>, for example:</p>
<pre class="r"><code>nmat &lt;- 10
mats &lt;- lapply(1:nmat, function(.nouse) matrix(rnorm(1e6), 1e3, 1e3))</code></pre>
<p>then one compact way of calculating their sum in <code>R</code> is <code>Reduce("+", M)</code>. Can we modify our <code>RcppArmadillo</code> code to handle any number of matrices? One way of doing this so that the compile-time efficiency tricks of <code>Armadillo</code> are exploited is based on some text editing. In particular, consider the following function:</p>
<pre class="r"><code>getMatSumFun &lt;- function(n){
  args &lt;- paste0(&quot;mat&amp; &quot;, paste0(&quot;A&quot;, 1:n), &quot;,&quot;, collapse = &#39; &#39;)
  args &lt;- substr(args, 1, nchar(args)-1)

  ret &lt;- paste0(paste0(&quot;A&quot;, 1:n), &quot; +&quot;, collapse = &#39; &#39;)
  ret &lt;- substr(ret, 1, nchar(ret)-2)

  funBody &lt;- paste0(&quot;
   // [[Rcpp::depends(RcppArmadillo)]]
   #include &lt;RcppArmadillo.h&gt;
   using namespace arma;

   // [[Rcpp::export(name = \&quot;mSum_arma_list\&quot;)]]
   mat mSum_i(&quot;, args, &quot;){
   return &quot;, ret, &quot;;
  }&quot;)

  return(funBody)
}</code></pre>
<p>Given <code>n</code>, this function creates the text for an <code>RcppArmadillo</code> function which sums up <code>n</code> matrices, in particular:</p>
<pre class="r"><code>armaCode &lt;- getMatSumFun(nmat)
cat(armaCode)</code></pre>
<pre><code>## 
##    // [[Rcpp::depends(RcppArmadillo)]]
##    #include &lt;RcppArmadillo.h&gt;
##    using namespace arma;
## 
##    // [[Rcpp::export(name = &quot;mSum_arma_list&quot;)]]
##    mat mSum_i(mat&amp; A1, mat&amp; A2, mat&amp; A3, mat&amp; A4, mat&amp; A5, mat&amp; A6, mat&amp; A7, mat&amp; A8, mat&amp; A9, mat&amp; A10){
##    return A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 + A9 + A10;
##   }</code></pre>
<p>Writing down the sum explicily guarantees that <code>Armadillo</code> will avoid creating temporary matrices. We can now compare the <code>R</code> and <code>Armadillo</code> solutions:</p>
<pre class="r"><code>sourceCpp(code = armaCode)

microbenchmark(R = Reduce(&quot;+&quot;, mats), arma = do.call(&quot;mSum_arma_list&quot;, mats))</code></pre>
<pre><code>## Unit: milliseconds
##  expr     min       lq     mean   median       uq     max neval
##     R 24.1347 25.08660 29.53970 26.50585 29.79065 79.2784   100
##  arma  9.6087 10.10005 10.91385 10.22510 11.55030 14.8566   100</code></pre>
</div>
<div id="basic-rcpparmadillo-usage" class="section level3">
<h3>Basic <code>RcppArmadillo</code> usage</h3>
<p>Here we describe some commonly used features of <code>RcppArmadillo</code> and <code>Armadillo</code>. The <code>Armadillo</code> library is quite extensive, hence we refer to its <a href="http://arma.sourceforge.net/docs.html">documentation</a> for more details. The most commonly used object classes are:</p>
<ul>
<li><code>Mat&lt;type&gt;</code> which represents dense matrices, with element types defined via the template argument <code>type</code>. In the
examples above we used <code>mat</code> which is an alias or typedef for <code>Mat&lt;double&gt;</code>.</li>
<li><code>Col&lt;type&gt;</code> and <code>Row&lt;type&gt;</code> which represent column and row vectors. Shortcuts for <code>Col&lt;double&gt;</code> and <code>Row&lt;double&gt;</code> are
<code>colvec</code> (or just <code>vec</code>) and <code>rowvec</code>.</li>
</ul>
<p><code>Armadillo</code> provides also 3D matrices, sparse matrices and fields (matrices whose elements can be arbitrary objects, such as matrices), which we will not use here. In order to effectively use an <code>Armadillo</code> object class, we need to know (or look in the <a href="http://arma.sourceforge.net/docs.html">documentation</a> for):</p>
<ol style="list-style-type: decimal">
<li>the <strong>constructor</strong> types available for such class. For example, a matrix of doubles <code>A</code> could be construted using
<code>mat A(10, 5)</code> or <code>mat A(10, 5, fill::zeros)</code>, for example. The difference being that in the first case the
entries of the <span class="math inline">\(10 \times 5\)</span> matrix <code>A</code> are arbitrary, while in the second they are set to 0.</li>
<li>The member <strong>functions and variables</strong> of that class. These are accessed using <code>object.member_function()</code> or
<code>object.variable</code>. For example, if <code>y</code> is a <code>Col&lt;float&gt;</code> vector, the <code>y.n_elem</code> gives its lengths while <code>y.ones()</code>
sets all its elements to 1. The <a href="http://arma.sourceforge.net/docs.html">docs</a> clearly explain which member functions
are available for each object class.</li>
<li>How the elements of the objects can be accessed. This is documented as part of the “Member Functions &amp; Variables”
section the <code>Armadillo</code> docs. An element <span class="math inline">\(ij\)</span> of a matrix <code>A</code> of class <code>Mat</code> can be accessed via <code>A(i-1,j-1)</code>, as
indexing starts at zero. It can also be accessed via <code>A.at(i-1,j-1)</code> which is faster but more dangerous as no
bounds check is performed (hence we could read/write outside the memory allocated to <code>A</code>).</li>
<li>The available <strong>operators</strong> and <strong>functions</strong>. Operators are overloaded so if, for example, <code>A</code> and <code>B</code> are
matrices while <code>s</code> is a scalar, then <code>A * B</code> will calculate the standard matrix product while <code>A * s</code> will
multiply each element of <code>A</code> by <code>s</code>. Several element-wise functions are provided (e.g., <code>exp(A)</code>, <code>sqrt(A)</code>, …),
as well as standard decomposition (e.g, Cholesky, LU, …) and solvers for linear systems.</li>
</ol>
<p>Some guidance on how standard linear algebra operations in <code>R</code> can be translated to <code>RcppArmadillo</code> is provided <a href="https://github.com/petewerner/misc/wiki/RcppArmadillo-cheatsheet">here</a>. Before moving to a more involved example, we clarify the relation between <code>Armadillo</code> objects and <code>Rcpp</code> matrices and vectors. Conversion from <code>Armadillo</code> object to <code>Rcpp</code> object is performed using <code>Rcpp::wrap</code>, for example:</p>
<pre class="r"><code>sourceCpp(code = &#39;
// [[Rcpp::depends(RcppArmadillo)]]
#include &lt;RcppArmadillo.h&gt;
using namespace arma;

// [[Rcpp::export(name = &quot;getIntMat&quot;)]]
Mat&lt;int&gt; tmpFun_i(int nr, int nc) {
  Mat&lt;int&gt; MA(nr, nc);
  Rcpp::IntegerMatrix MR = Rcpp::wrap(MA);
  MR[0, 0] = 1;
  return MA;
}&#39;)

getIntMat(3, 3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    0    0    0
## [2,]    0    0    0
## [3,]    0    0    0</code></pre>
<p>Here we are creating a <span class="math inline">\(3 \times 3\)</span> un-initialized integer matrix in <code>Armadillo</code> and we are converting it to an <code>Rcpp::IntegerMatrix</code> using <code>wrap</code>. It is interesting to note that here <code>Rcpp::wrap</code> is copying <code>MA</code>, which is demostrated by the fact that changing the top-left element of <code>MR</code> does not entail changing <code>MA</code>. The following version avoids any copy:</p>
<pre class="r"><code>sourceCpp(code = &#39;
// [[Rcpp::depends(RcppArmadillo)]]
#include &lt;RcppArmadillo.h&gt;
using namespace arma;

// [[Rcpp::export(name = &quot;getIntMat_noCopy&quot;)]]
Rcpp::IntegerMatrix tmpFun_i(int nr, int nc) {
  Rcpp::IntegerMatrix MR(nr, nc);
  Mat&lt;int&gt; MA(MR.begin(), MR.nrow(), MR.ncol(), false);
  MA(0, 0) = 1;
  return MR;
}&#39;)

getIntMat_noCopy(3, 3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    0    0
## [3,]    0    0    0</code></pre>
<p>Let’s see how this worked step by step:</p>
<ul>
<li><code>Rcpp::IntegerMatrix MR(nr, nc)</code> here we <strong>allocated memory in R</strong> for the matrix <code>MR</code>;</li>
<li><code>Mat&lt;int&gt; MA(MR.begin(), MR.nrow(), MR.ncol(), false)</code> here we used the advanced <code>Armadillo</code>
<a href="http://arma.sourceforge.net/docs.html#adv_constructors_col">constructor</a>, which constructs a <code>Mat&lt;int&gt;</code>
matrix <code>MA</code> by reusing the memory allocated to <code>MR</code>. Hence no copy is made and changes in <code>MA</code> leads to
changes in <code>MR</code>.</li>
<li>We return the <code>IntegerMatrix</code> <code>MR</code>. Given that its memory is allocated in <code>R</code>, no copy is made when
the object is returned. In particular, recall that <code>sourceCpp</code> will create a wrapper around our <code>C++</code> function,
and the wrapper will contain the line <code>Rcpp::wrap(tmpFun_i(nr, nc))</code>, as you can verify by calling
<code>sourceCpp</code> with <code>verbose = TRUE</code>. In <code>getIntMat</code>, <code>Rcpp::wrap</code> was taking a copy, because the output
of <code>tmpFun_i</code> does not use <code>R</code> memory, while this is avoided in <code>getIntMat_noCopy</code>.</li>
</ul>
<p>In summary <code>getIntMat</code> allocates memory outside <code>R</code> via <code>Mat&lt;int&gt; MA(nr, nc);</code> then takes one copy when we do <code>Rcpp::wrap(MA)</code> and another copy when <code>Rcpp::wrap</code> is called within the wrapper written by <code>sourceCpp</code>. In contrast,
<code>getIntMat_noCopy</code> allocates <code>R</code> memory via <code>Rcpp::IntegerMatrix MR(nr, nc);</code> and does no take any copy. This makes the second version much more efficient, in fact:</p>
<pre class="r"><code>d &lt;- 1e3
microbenchmark(copy = getIntMat(d, d), noCopy = getIntMat_noCopy(d, d))</code></pre>
<pre><code>## Unit: microseconds
##    expr    min      lq     mean  median      uq    max neval
##    copy 1926.8 3995.75 4857.853 5538.20 5652.40 9081.4   100
##  noCopy  675.9  688.90 1572.278 1808.05 2147.15 5350.0   100</code></pre>
<p>The bottom line is that, when we want to manipulate large matrices or vectors in <code>RcppArmadillo</code>, it is often more efficient to:</p>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li>allocate memory in <code>R</code> and then pass the objects by reference (e.g., via <code>mat&amp;</code>, <code>vec&amp;</code>, …) to the <code>Rcpp</code> function
or (b) to allocate <code>R</code> memory directly in <code>Rcpp</code> via one of its data structure (e.g., <code>NumericMatrix</code>, <code>NumericVector</code>, …);</li>
</ol></li>
<li>wrap the <code>R</code> object into <code>Armadillo</code> objects using an advanced constructor, such as the one we have see above;</li>
<li>manipulate the <code>Armadillo</code> objects using the operators and functions provided by <code>Armadillo</code>;</li>
<li>return an <code>Rcpp</code> data structure to avoid copies being made by <code>Rcpp::wrap</code>.</li>
</ol>
<p>The advanced constructor provides a way of converting <code>Rcpp</code> objects into <code>Armadillo</code> objects, without taking a copy. Often taking a copy is acceptable, in which case it is more convenient to perform the conversion using the <code>Rcpp::as&lt;type&gt;()</code> function, where the template argument <code>type</code> can be an <code>Armadillo</code> object class such as <code>Mat&lt;int&gt;</code>, <code>Row&lt;double&gt;</code> and so on. An example is:</p>
<pre class="r"><code>sourceCpp(code = &#39;
// [[Rcpp::depends(RcppArmadillo)]]
#include &lt;RcppArmadillo.h&gt;
using namespace arma;

// [[Rcpp::export(name = &quot;matVettArma&quot;)]]
Col&lt;double&gt; tmpFun_i(Rcpp::NumericMatrix X, Rcpp::NumericVector y) {
  Mat&lt;double&gt; Xa = Rcpp::as&lt;Mat&lt;double&gt;&gt;(X);
  Col&lt;double&gt; ya = Rcpp::as&lt;Col&lt;double&gt;&gt;(y);
  return Xa*ya;
}&#39;)

matVettArma(matrix(1, 3, 3), 1:3)</code></pre>
<pre><code>##      [,1]
## [1,]    6
## [2,]    6
## [3,]    6</code></pre>
<p>which performs matrix-vector multiplication in <code>Armadillo</code>. Note that <code>Rcpp::as</code> generally takes a copy of the object being converted.</p>
</div>
<div id="references" class="section level3">
<h3>References</h3>
<ul>
<li><p>Armadillo project: <a href="http://arma.sourceforge.net/" class="uri">http://arma.sourceforge.net/</a></p></li>
<li><p>Conrad Sanderson and Ryan Curtin. Armadillo: a template-based C++ library for linear algebra.
Journal of Open Source Software, Vol. 1, pp. 26, 2016.</p></li>
<li><p>Dirk Eddelbuettel and Conrad Sanderson, “RcppArmadillo: Accelerating R with high-performance
C++ linear algebra”, Computational Statistics and Data Analysis, 2014, 71, March, pages 1054-
1063, <a href="http://dx.doi.org/10.1016/j.csda.2013.02.005" class="uri">http://dx.doi.org/10.1016/j.csda.2013.02.005</a>. )</p></li>
</ul>
</div>


  <footer>
  

<script src="//yihui.name/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>


<script type="text/javascript">
var sc_project=12110974;
var sc_invisible=1;
var sc_security="9b171880";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><a title="Web Analytics"
href="https://statcounter.com/" target="_blank"><img
class="statcounter"
src="https://c.statcounter.com/12110974/0/9b171880/1/"
alt="Web Analytics"></a></div></noscript>








  


<p align=right>

<a href='https://github.com/mfasiolo/sc2-2019/blob/master/content/rcpp_advanced_I/2_RcppArmadillo.Rmd'>View source</a>

|

<a href='https://github.com/mfasiolo/sc2-2019/edit/master/content/rcpp_advanced_I/2_RcppArmadillo.Rmd'>Edit source</a>

</p>





<script src="https://utteranc.es/client.js"
        repo="awllee/sc1-2019"
        issue-term="pathname"
        label="utterance"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



  



<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/tex.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">© 2020 <a href="https://mfasiolo.github.io/">Matteo Fasiolo</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

