<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>1. Using R&#39;s C API - SC2</title>
    <meta property="og:title" content="1. Using R&#39;s C API - SC2">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="The purpose of this section is explaining how to interface R with C/C&#43;&#43; using the raw C API provided by R. In practice it is generally preferable to use the Rcpp package to interface R with C&#43;&#43;, but &amp;hellip;">
      <meta property="og:description" content="The purpose of this section is explaining how to interface R with C/C&#43;&#43; using the raw C API provided by R. In practice it is generally preferable to use the Rcpp package to interface R with C&#43;&#43;, but &amp;hellip;">
      
    

    
    

    

    
    


<link href='//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Arvo">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Marcellus">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">

<link rel="stylesheet" href="/sc2-2019/css/style.css" />
<link rel="stylesheet" href="/sc2-2019/css/fonts.css" />
<link rel="stylesheet" href="/sc2-2019/css/custom.css" />

<link rel="icon" href="/sc1-2019/favicon.ico" type="image/x-icon" />























<nav class="breadcrumbs">
    
        <a href="https://mfasiolo.github.io/sc2-2019/">home / </a>
    
        <a href="https://mfasiolo.github.io/sc2-2019/rcpp/">rcpp / </a>
    
        <a href="https://mfasiolo.github.io/sc2-2019/rcpp/1_r_internals/">1_r_internals / </a>
    
</nav>

  </head>

  
  <body class="sc2-2019">
    <header class="masthead">
      <h1><a href="/">SC2</a></h1>

<p class="tagline">Statistical Computing 2</p>

      <nav class="menu">
  <input id="menu-check" type="checkbox" hidden/>
  <label id="menu-label" for="menu-check" class="unselectable" hidden>
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li><a href="/sc2-2019/">Home</a></li>
  
  <li><a href="/sc2-2019/rcpp/">Integrating R and C</a></li>
  
  <li><a href="/sc2-2019/rcpp_advanced_i/">Advanced Rcpp I</a></li>
  
  <li><a href="/sc2-2019/rcpp_advanced_ii/">Advanced Rcpp II</a></li>
  
  <li><a href="/sc2-2019/rcpp_advanced_iii/">Parallel Rcpp</a></li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>1. Using R&#39;s C API</h1>

<h3>
</h3>
<hr>


      </header>







<div id="TOC">
<ul>
<li><a href="#creating-c-functions-that-are-callable-from-r" id="toc-creating-c-functions-that-are-callable-from-r">Creating C functions that are callable from R</a></li>
<li><a href="#calling-expsmooth-from-r" id="toc-calling-expsmooth-from-r">Calling expSmooth from R</a></li>
<li><a href="#creating-r-objects-within-c-code" id="toc-creating-r-objects-within-c-code">Creating R objects within C code</a></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</div>

<style>
body {
text-align: justify}
</style>
<p>The purpose of this section is explaining how to interface R with C/C++ using the raw C API provided by R. In practice it is generally preferable to use the <code>Rcpp</code> package to interface R with C++, but it is useful to know how R’s C API works to have an idea of what is going on under the hood when you use <code>Rcpp</code>. Besides, many of the functions in base R are written in C using the R’s C API and do not use <code>Rcpp</code>. This section assumes that you have some basic knowledge of C.</p>
<div id="creating-c-functions-that-are-callable-from-r" class="section level3">
<h3>Creating C functions that are callable from R</h3>
<p>To provide some motivation, consider the following data:</p>
<pre class="r"><code>library(gamair)
library(tibble)
data(chicago)
chicago &lt;- as_tibble(chicago)
chicago</code></pre>
<pre><code>## # A tibble: 5,114 × 7
##    death pm10median pm25median o3median so2median   time  tmpd
##    &lt;int&gt;      &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1   130     -7.43          NA    -19.6     1.93  -2556.  31.5
##  2   150     NA             NA    -19.0    -0.986 -2556.  33  
##  3   101     -0.827         NA    -20.2    -1.89  -2554.  33  
##  4   135      5.57          NA    -19.7     6.14  -2554.  29  
##  5   126     NA             NA    -19.2     2.28  -2552.  32  
##  6   130      6.57          NA    -17.6     9.86  -2552.  40  
##  7   129     -0.434         NA    -15.4    -5.82  -2550.  34.5
##  8   109     -5.43          NA    -12.2    -5.11  -2550.  29  
##  9   125     -0.571         NA    -20.1     0.182 -2548.  26.5
## 10   153     NA             NA    -18.6    -2.05  -2548.  32.5
## # … with 5,104 more rows</code></pre>
<p>The <code>chicago</code> data set contains data on daily air pollution and death rate for Chicago (see <code>?chicago</code> for details). Given this data, one might be interested in analysing the relation between the number of deaths and air pollution. In particular, one could consider the following GAM model (taken from Wood, 2017, page 347)
<span class="math display">\[
\text{death}_t \sim \text{Poi}(\lambda_t),
\]</span>
<span class="math display">\[
\log \lambda_t = f_1(\text{time}_t) + f_2(\text{pm10}_t) + f_3(\text{so2}_t) + f_4(\text{o3}_t) + f_5(\text{tmpd}_t),
\]</span>
Which can be fitted using <code>mgcv</code> as follows:</p>
<pre class="r"><code>library(mgcViz)
fit0 &lt;- bam(death ~ s(time, k = 200) + s(pm10median) + s(so2median) + s(o3median) +
                    s(tmpd),
            data = chicago, family = poisson, discrete = TRUE)</code></pre>
<p>Then we can use <code>mgcViz</code> to plot the effect of the three pollutants and of the daily temperature:</p>
<pre class="r"><code>fit0 &lt;- getViz(fit0)
print(plot(fit0, select = 2:5), pages = 1)</code></pre>
<p><img src="/sc2-2019/rcpp/1_R_internals_files/figure-html/unnamed-chunk-3-1.png" width="672" style="display: block; margin: auto;" />
The effect of <code>so2</code> doesn’t seem to be important, hence it might make sense to remove it from the model. Another thing that we could try, is to check whether the number of deaths depends on the temperatures (<code>tmpd</code>) registered in the last few days, rather than only on the temperature on the same day. Rather than simply using lagged values of the temperature, we could consider building a new variable obtained by exponentially smoothing the temperature, that is
<span class="math display">\[
\text{tmpdSmooth}_t = \alpha \, \text{tmpdSmooth}_{t-1} + (1 - \alpha) \, \text{tmpd}_t,
\]</span>
with <span class="math inline">\(\alpha \in (0, 1)\)</span>.</p>
<p>Now, assume that we want to implement a function, say, <code>expSmooth</code> to calculate the exponential smooth of a variable in C, and that we want to be able to call it from R. The C code for such a function is:</p>
<pre class="cpp"><code>#include &lt;R.h&gt;
#include &lt;Rinternals.h&gt;

SEXP expSmooth(SEXP y, SEXP ys, SEXP n, SEXP a)
{
  int ni;
  double *xy, *xys;
  double ai;
  
  xy = REAL(y); 
  xys = REAL(ys);
  ni = INTEGER(n)[0];
  ai = REAL(a)[0];

  xys[0] = xy[0];
  for(int i = 1; i &lt; ni; i++){
    xys[i] = ai * xys[i-1] + (1 - ai) * xy[i];
  }
  
  return R_NilValue;
}</code></pre>
<p>Before explaining how <code>expSmooth</code> can be called from R, let’s try to break it down. The first two lines are there to include two header files that contain some R-related C functions and macros. For example <code>REAL</code> is defined in <code>Rinternals.h</code> as can be verified by looking at the source code by doing (not shown here):</p>
<pre class="r"><code>rinternals &lt;- file.path(R.home(&quot;include&quot;), &quot;Rinternals.h&quot;)
file.show(rinternals)</code></pre>
<p>The <code>expSmooth</code> function returns an <code>SEXP</code>, which is also the class of its inputs. A object of class <code>SEXP</code> is a pointer to an S expression, that is a pointer to an object in the R environment. Hence, importantly, the inputs are passed to <code>expSmooth</code> by reference and are not copied. Here our inputs are:</p>
<ul>
<li><code>y</code>, the vector to be smoothed;</li>
<li><code>ys</code>, the vector which will contain the smoothed version of <code>y</code>;</li>
<li><code>n</code>, a scalar indicating the length of <code>y</code> and <code>ys</code>;</li>
<li><code>a</code>, the <span class="math inline">\(\alpha\)</span> coefficient.</li>
</ul>
<p>Even though all the arguments of <code>expSmooth</code> are of class <code>SEXP</code>, it is important to know that <code>SEXP</code> is a variant type, that is a C object whose subtype is known only at runtime, with subtypes that cover all data structures in R. Examples of subtypes are:</p>
<ul>
<li><code>REALSXP</code> a numeric vector such as <code>c(1.2, 0.45)</code>;</li>
<li><code>LGLSXP</code> a logical vector such as <code>c(TRUE, FALSE, FALSE)</code>;</li>
<li><code>INTSXP</code> an integer vector such as <code>c(2L, 34L, 1L)</code>;</li>
<li><code>VECSXP</code> a list such as <code>list("a" = 2, "b" = c(5, 4))</code>.</li>
</ul>
<p>See the <a href="https://cran.r-project.org/doc/manuals/R-ints.html#R-Internal-Structures">R internal documentation</a> for a complete list.</p>
<p>The first lines of the function’s body are:</p>
<pre class="cpp"><code>int ni;
double *xy, *xys;
double ai;</code></pre>
<p>where we are creating four C objects, which are initialized using:</p>
<pre class="cpp"><code>xy = REAL(y); 
xys = REAL(ys);
ni = INTEGER(n)[0];
ai = REAL(a)[0];</code></pre>
<p>We are using the <a href="https://gcc.gnu.org/onlinedocs/cpp/Macro-Arguments.html">macro function</a> <code>REAL</code> to access object <code>y</code>. In particular, <code>REAL</code> returns a double pointer to the real part of the <code>SEXP</code> <code>y</code>. Similarly, <code>INTEGER(n)</code> returns a pointer to the integer part of <code>n</code> and by doing <code>[0]</code> we are extracting the value of its first element. Hence, here there is the assumption that the subtype of <code>y</code> is <code>REALSXP</code> and that the subtype of <code>n</code> is <code>INTSXP</code>. Otherwise if, for example, <code>n</code> was a real vector of type <code>REALSXP</code>, calling <code>INTEGER</code> would trigger an error at runtime, as we shall see.</p>
<p>The computation actually happens here:</p>
<pre class="cpp"><code>xys[0] = xy[0];
for(int i = 1; i &lt; ni; i++){
  xys[i] = ai * xys[i-1] + (1 - ai) * xy[i];
}</code></pre>
<p>In the first line we are initializing by setting <span class="math inline">\(\text{tmpdSmooth}_1 = \text{tmpd}_1\)</span>, than the rest is straighforward C code. Notice that the function returns:</p>
<pre class="cpp"><code>return R_NilValue;</code></pre>
<p>where <code>R_NilValue</code> is defined in <code>Rinternals.h</code> and it’s the C equivalent of R’s <code>NULL</code>. Hence the function is not returning anything useful, but the smoothed variable is obtained by modifying the <code>xys</code> vector in place (that is, without making a copy).</p>
</div>
<div id="calling-expsmooth-from-r" class="section level3">
<h3>Calling expSmooth from R</h3>
<p>Now, assume that <code>expSmooth</code> is contained in a file called <code>expSmooth.c</code>, which in our case can be found in our working directory, as you could see from the following call to the command line (the output is hidden here):</p>
<pre class="r"><code>system(&quot;ls *.c&quot;)</code></pre>
<p>Here we will explain how to call <code>expSmooth</code> using the <code>.Call</code> interface in R. <code>.Call</code> can be used to call C functions that accept variables of class <code>SEXP</code> as inputs and return an object of class <code>SEXP</code>. Indeed, we created the <code>expSmooth</code> function with this requirement in mind.</p>
<p>The first thing that we need to do is to compile the C code as follows</p>
<pre class="r"><code>system(&quot;R CMD SHLIB expSmooth.c&quot;)</code></pre>
<p>This will create two files, <code>expSmooth.o</code> and <code>expSmooth.so</code>, containing binary code. The <code>.so</code> object is a shared object which can be loaded in R by doing:</p>
<pre class="r"><code>dyn.load(&quot;expSmooth.so&quot;)</code></pre>
<p>Having done this, the <code>expSmooth</code> function is now available at R level:</p>
<pre class="r"><code>is.loaded(&quot;expSmooth&quot;)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>See the <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Creating-shared-objects">Creating shared objects</a> section of the <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html">Writing R Extensions</a> manual for more details on how this works.</p>
<p>Having loaded <code>expSmooth</code> in R, we can now call it using <code>.Call</code>:</p>
<pre class="r"><code>nch &lt;- nrow( chicago )
tmpSmooth &lt;- numeric(nch)

.Call(&quot;expSmooth&quot;, chicago$tmpd, tmpSmooth, nch, 0.8)</code></pre>
<pre><code>## NULL</code></pre>
<p>As expected the function returns <code>NULL</code>, but the smoothed temperature is now contained in <code>tmpSmooth</code>:</p>
<pre class="r"><code>plot(chicago$tmpd[1:1000], col = &quot;grey&quot;, ylab = &quot;Temp&quot;)
lines(tmpSmooth[1:1000], col = 2)</code></pre>
<p><img src="/sc2-2019/rcpp/1_R_internals_files/figure-html/unnamed-chunk-15-1.png" width="528" style="display: block; margin: auto;" />
To check whether our function actually works, let’s compare it with an R version of it:</p>
<pre class="r"><code>expSmoothR &lt;- function(x, a){

  n &lt;- length(x)
  xs &lt;- x

  for(ii in 2:n){
   xs[ii] &lt;- a * xs[ii - 1] + (1 - a) * x[ii]
  }

  return(xs)

}</code></pre>
<p>The output of the R and C version is identical:</p>
<pre class="r"><code>max( abs(tmpSmooth - expSmoothR(chicago$tmpd, 0.8)) )</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Having verified that our C function for exponential smoothing does the right thing, let’s see how it compares with its R version in terms of computing time:</p>
<pre class="r"><code>smoR &lt;- function() expSmoothR(chicago$tmpd, 0.8)
smoC &lt;- function() .Call(&quot;expSmooth&quot;, chicago$tmpd, tmpSmooth, nch, 0.8)

library(microbenchmark)
microbenchmark(smoR(), smoC(), times = 500)</code></pre>
<pre><code>## Unit: microseconds
##    expr   min    lq     mean median    uq    max neval
##  smoR() 582.9 585.5 592.1336  587.2 590.6 1970.0   500
##  smoC()  18.9  19.1  21.9564   19.1  19.3 1330.7   500</code></pre>
<p>So the C version is more than 10 times faster. The comparison it somewhat unfair, because the R function is allocating memory containing the smoothed temperature at every call, while the C version is re-using the memory allocated to the <code>tmpSmooth</code> vector. However, the ability to overwrite R objects without copying them is one of the reasons for interfacing R with C.</p>
<p>We now go back to our original application, and fit a model which excludes <code>so2</code> which didn’t seem to matter and that includes the effect of smoothed temperature:</p>
<pre class="r"><code>chicago$tmpSmooth &lt;- tmpSmooth
fit1 &lt;- bam(death ~ s(time, k = 200) + s(pm10median) + s(o3median) +
                    s(tmpd) + s(tmpSmooth),
                   data = chicago, family = poisson, discrete = TRUE)</code></pre>
<p>We now plot the effects of the two temperature effects:</p>
<pre class="r"><code>fit1 &lt;- getViz(fit1)
print(plot(fit1, select = 4:5), pages = 1)</code></pre>
<p><img src="/sc2-2019/rcpp/1_R_internals_files/figure-html/unnamed-chunk-20-1.png" width="672" style="display: block; margin: auto;" />
The plots shows that the effect of smoothed temperature is quite important, and the new model seems to do better than the old model in terms of AIC:</p>
<pre class="r"><code>AIC(fit0, fit1)</code></pre>
<pre><code>##            df      AIC
## fit0 145.0587 37889.99
## fit1 141.5415 37862.83</code></pre>
</div>
<div id="creating-r-objects-within-c-code" class="section level3">
<h3>Creating R objects within C code</h3>
<p>Here we try to refine the <code>expSmooth</code> function created above. Firstly notice that, while <code>expSmooth</code> does not make any explicit assumption about the subtype of its <code>SEXP</code> input, trying to smooth the number of death leads to:</p>
<pre class="r"><code>.Call(&quot;expSmooth&quot;, chicago$death, tmpSmooth, nch, 0.8)
# Error: REAL() can only be applied to a &#39;numeric&#39;, not a &#39;integer&#39;</code></pre>
<p>Because <code>xy = REAL(y);</code> triggers an error which signals that <code>y</code> should be a vector of reals, not of integers. To smooth the number of death we must pass <code>as.double(chicago$death)</code>. However, <code>expSmooth</code> does not check for other things as well. For example, there nothing guaranteeing that argument <code>n</code> matches the length of the input vectors <code>y</code> and <code>ys</code>. For example, the following code:</p>
<pre class="r"><code>.Call(&quot;expSmooth&quot;, chicago$tmpd, tmpSmooth, nch + 10L, 0.8) # do NOT run this!</code></pre>
<p>might run without any indication that something wrong has happened. But <span class="math inline">\(n\)</span> is 10 units longer than <code>length(chicago$tmpd)</code>, which mean that the last 10 iterations of this loop:</p>
<pre class="cpp"><code>for(int i = 1; i &lt; ni; i++){
  xys[i] = ai * xys[i-1] + (1 - ai) * xy[i];
}</code></pre>
<p>are reading outside the memory allocated to <code>xy</code> and writing outside the memory allocated to <code>xys</code>. This is a serious problem, and our current version of <code>expSmooth</code> is entirely relying on the assumption that the user will call it with the right arguments.</p>
<p>A safer version of <code>expSmooth</code> might be something like this:</p>
<pre class="cpp"><code>#include &lt;R.h&gt;
#include &lt;Rinternals.h&gt;

SEXP expSmooth2(SEXP y, SEXP a)
{
  int ni;
  double *xy, *xys;
  double ai;
  SEXP ys;
  
  y = PROTECT(coerceVector(y, REALSXP));
  ni = length(y);
  ys = PROTECT(allocVector(REALSXP, ni));
  
  ai = REAL(a)[0];
  xy = REAL(y); 
  xys = REAL(ys);
  
  xys[0] = xy[0];
  for(int i = 1; i &lt; ni; i++){
    xys[i] = ai * xys[i-1] + (1 - ai) * xy[i];
  }
  
  UNPROTECT(2);
  
  return ys;
}</code></pre>
<p>Notice that <code>expSmooth2</code> has only two arguments: the variable to be smoothed <code>y</code> and the smoothing coefficient <code>a</code>. Then here:</p>
<pre class="cpp"><code>y = PROTECT(coerceVector(y, REALSXP));
ni = length(y);</code></pre>
<p>we are using <code>coerceVector</code> to convert <code>y</code> to subtype <code>REALSXP</code> hence this is analogous to doing <code>as.double</code> in R. The output of <code>coerceVector</code> must be protected from R’s garbage collector using <code>PROTECT</code>, otherwise the memory allocated to <code>y</code> might be deallocated before we finished using it. All R objects allocated in C code must be protected, as failing to do so might lead to intermittent crashes and hard to find bugs. See this <a href="https://developer.r-project.org/Blog/public/2019/04/18/common-protect-errors/">blog post</a> for more details. The next line just extracts the length of <code>y</code> and stores it in <code>ni</code>, thus removing the need to pass the length of <code>y</code> as an argument.</p>
<p>Then we allocate memory for the smoothed output:</p>
<pre class="cpp"><code>ys = PROTECT(allocVector(REALSXP, ni));</code></pre>
<p>where we are allocating memory for a vector of doubles with <code>ni</code> elements. This also must be protected, because we are allocating an R object (<code>allocVector</code> is defined in <code>Rinternals.h</code>). The main loop is the same, but <code>expSmooth2</code> ends with:</p>
<pre class="cpp"><code>UNPROTECT(2);
return ys;</code></pre>
<p>where we are unprotecting two objects and then returning <code>ys</code>. It is important to UNPROTECT as many objects as you have protected, and to UNPROTECT just before returning to R. Failing to UNPROTECT will lead to memory leakage, that is to R objects hanging around in memory while not being useful or accessible in any way.</p>
<p>Having created our new C function, which can be found in <code>expSmooth2.c</code>, we compile it and load it:</p>
<pre class="r"><code>system(&quot;R CMD SHLIB expSmooth2.c&quot;)
dyn.load(&quot;expSmooth2.so&quot;)</code></pre>
<p>We compare its output with that of the R version:</p>
<pre class="r"><code>max(abs(.Call(&quot;expSmooth2&quot;, chicago$tmpd, 0.8) - expSmoothR(chicago$tmpd, 0.8)))</code></pre>
<pre><code>## [1] 0</code></pre>
<p>which shows that it is working correctly. The computing time is also comparable to that of the old C function:</p>
<pre class="r"><code>smoR &lt;- function() expSmoothR(chicago$tmpd, 0.8)
smoC &lt;- function() .Call(&quot;expSmooth&quot;, chicago$tmpd, tmpSmooth, nch, 0.8)
smoC2 &lt;- function() .Call(&quot;expSmooth2&quot;, chicago$tmpd, 0.8)

library(microbenchmark)
microbenchmark(smoR(), smoC(), smoC2(), times = 500)</code></pre>
<pre><code>## Unit: microseconds
##     expr   min    lq     mean median    uq    max neval
##   smoR() 582.5 585.6 591.8938 587.25 590.9 1672.6   500
##   smoC()  19.7  19.9  23.2574  20.00  20.2 1541.0   500
##  smoC2()  18.9  19.2  21.6634  19.30  19.6 1045.4   500</code></pre>
<p>despite the fact that it is allocating memory for the output vector at every call. Importantly, <code>expSmooth2</code> is safer and works directly with integer input vectors:</p>
<pre class="r"><code>plot(chicago$death[1:1000], col = &quot;grey&quot;)
lines(.Call(&quot;expSmooth2&quot;, chicago$death, 0.8)[1:1000], col = 2)</code></pre>
<p><img src="/sc2-2019/rcpp/1_R_internals_files/figure-html/unnamed-chunk-32-1.png" width="528" style="display: block; margin: auto;" /></p>
</div>
<div id="references" class="section level3">
<h3>References</h3>
<ul>
<li><p>Chambers, J.M., 2017. Extending R. Chapman and Hall/CRC.</p></li>
<li><p>CRAN. R internals, see <a href="https://cran.r-project.org/doc/manuals/r-release/R-ints.html" class="uri">https://cran.r-project.org/doc/manuals/r-release/R-ints.html</a></p></li>
<li><p>CRAN. Writing R extensions, see <a href="https://cran.r-project.org/doc/manuals/R-exts.html" class="uri">https://cran.r-project.org/doc/manuals/R-exts.html</a></p></li>
<li><p>Wickham H.. R’s C interface, see <a href="http://adv-r.had.co.nz/C-interface.html" class="uri">http://adv-r.had.co.nz/C-interface.html</a></p></li>
<li><p>Wickham H.. R internals, see <a href="https://github.com/hadley/r-internals" class="uri">https://github.com/hadley/r-internals</a></p></li>
</ul>
</div>



  <footer>
  

<script src="//yihui.name/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>


<script type="text/javascript">
var sc_project=12110974;
var sc_invisible=1;
var sc_security="9b171880";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><a title="Web Analytics"
href="https://statcounter.com/" target="_blank"><img
class="statcounter"
src="https://c.statcounter.com/12110974/0/9b171880/1/"
alt="Web Analytics"></a></div></noscript>








  


<p align=right>

<a href='https://github.com/mfasiolo/sc2-2019/blob/master/content/rcpp/1_R_internals.Rmd'>View source</a>

|

<a href='https://github.com/mfasiolo/sc2-2019/edit/master/content/rcpp/1_R_internals.Rmd'>Edit source</a>

</p>





<script src="https://utteranc.es/client.js"
        repo="awllee/sc1-2019"
        issue-term="pathname"
        label="utterance"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



  



<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/tex.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">© 2020 <a href="https://mfasiolo.github.io/">Matteo Fasiolo</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

