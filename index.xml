<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on SC2</title>
    <link>https://mfasiolo.github.io/sc2-2019/</link>
    <description>Recent content in Home on SC2</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://mfasiolo.github.io/sc2-2019/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1. Rcpp sugar</title>
      <link>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/1_rcpp_sugar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/1_rcpp_sugar/</guid>
      <description>Vectorized operators and sugar versions of basic R functions Random number generation    body { text-align: justify}  In a previous chapter we explained how Rcpp allows users to interface R with C++ in convenient way. Here we cover Rcpp sugar, which consists of a set of functions and operators which make the C++ code written using Rcpp behave similarly to what would happen in R. In other words Rcpp sugar allows us to write C++ code which is similar to the R equivalent, but often more efficient.</description>
    </item>
    
    <item>
      <title>1. Using R&#39;s C API</title>
      <link>https://mfasiolo.github.io/sc2-2019/rcpp/1_r_internals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mfasiolo.github.io/sc2-2019/rcpp/1_r_internals/</guid>
      <description>Creating C functions that are callable from R Calling expSmooth from R Creating R objects within C code References    body { text-align: justify}  The purpose of this section is explaining how to interface R with C/C++ using the raw C API provided by R. In practice it is generally preferable to use the Rcpp package to interface R with C++, but it is useful to know how R’s C API work to have an idea of what is going on under the hood when you use Rcpp.</description>
    </item>
    
    <item>
      <title>2. Exercises on chaotic maps and kernel regression smoothing</title>
      <link>https://mfasiolo.github.io/sc2-2019/rcpp/2_exercises/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mfasiolo.github.io/sc2-2019/rcpp/2_exercises/</guid>
      <description>Simulation based inference on the Ricker model Adaptive kernel regression smoothing    body { text-align: justify}  Simulation based inference on the Ricker model Here we consider an extremely simple model for population dynamics, the Ricker map: \[ y_{t+1} = ry_te^{-y_t}, \] where \(y_t&amp;gt;0\) represents the size of the population at time \(t\) and \(r&amp;gt;0\) is its growth rate. The model can show a wide range of dynamics, depending on the value of \(r\).</description>
    </item>
    
    <item>
      <title>2. RcppArmadillo</title>
      <link>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/2_rcpparmadillo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/2_rcpparmadillo/</guid>
      <description>Introduction Motivating example 1: matrix-matrix-vector product Motivating example 2: sums of matrices Basic RcppArmadillo usage References    body { text-align: justify}  Introduction Many standard statistical models/algorithms (e.g., linear regression, principal component analysis, …) require using numerical algebra routines, hence this section explains how to perform such computations efficiently using the RcppArmadillo R package. RcppArmadillo provides an interface to the Armadillo C++ numerical linear algebra library, which is highly useful in practice because it provides an interesting balance between performance and ease of use.</description>
    </item>
    
    <item>
      <title>3. Example on multivariate KDE with RcppArmadillo</title>
      <link>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/3_kde_armadillo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/3_kde_armadillo/</guid>
      <description>Introduction An R-based and a dumb Rcpp solution A better RcppArmadillo solution References    body { text-align: justify}  Introduction To provide a more challeging example illustrating the capabilities of RcppArmadillo, here we show how to perform multivariate kernel density estimation (k.d.e.) using this library. In particular, let \(\bf x_1^o, \dots, \bf x_n^o\) be \(d\)-dimensional vectors, sample from the density \(\pi(\bf x)\). A k.d.e. estimate of \(\pi({\bf x})\) is \[ \hat{\pi}_{\bf H}({\bf x}) = \frac{1}{n} \sum_{i=1}^n \kappa_{\bf H}({\bf x} - {\bf x}_i^o), \] where \(\kappa_{\bf H}\) is a kernel with positive definite bandwidth matrix \({\bf H}\).</description>
    </item>
    
    <item>
      <title>3. Rcpp basics</title>
      <link>https://mfasiolo.github.io/sc2-2019/rcpp/3_rcpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mfasiolo.github.io/sc2-2019/rcpp/3_rcpp/</guid>
      <description>Rcpp via R CMD SHLIB: the old but instructive way Rcpp via sourceCpp() Inline Rcpp via cppFunction() and evalCpp() References    body { text-align: justify}  Rcpp via R CMD SHLIB: the old but instructive way To illustrate how Rcpp works, let us consider again our C function for exponential smoothing, that is:
#include &amp;lt;R.h&amp;gt; #include &amp;lt;Rinternals.h&amp;gt; SEXP expSmooth2(SEXP y, SEXP a) { int ni; double *xy, *xys; double ai; SEXP ys; y = PROTECT(coerceVector(y, REALSXP)); ni = length(y); ys = PROTECT(allocVector(REALSXP, ni)); ai = REAL(a)[0]; xy = REAL(y); xys = REAL(ys); xys[0] = xy[0]; for(int i = 1; i &amp;lt; ni; i++){ xys[i] = ai * xys[i-1] + (1 - ai) * xy[i]; } UNPROTECT(2); return ys; } Now, the same function can be implemented in “raw” Rcpp as follows (as we will explain later this is NOT the recommended way of using Rcpp):</description>
    </item>
    
    <item>
      <title>3. Rcpp basics</title>
      <link>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_ii/junk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_ii/junk/</guid>
      <description>Rcpp via R CMD SHLIB: the old but instructive way    body { text-align: justify}  Rcpp via R CMD SHLIB: the old but instructive way # fObj &amp;lt;- function(.x) .x^2 # # fGrad &amp;lt;- function(.x, h = 1e-3) (fObj(.x+h) - fObj(.x)) / h # # x0 &amp;lt;- x1 &amp;lt;- 2 # xSeq1 &amp;lt;- numeric(500) # # for(ii in 1:500){ # x1 &amp;lt;- x0 - 0.01 * fGrad(x0) # x0 &amp;lt;- x1 # xSeq1[ii] &amp;lt;- x1 # } # # x0 &amp;lt;- x1 &amp;lt;- 2 # xSeq2 &amp;lt;- numeric(500) # # for(ii in 1:500){ # x1 &amp;lt;- x0 - 0.</description>
    </item>
    
    <item>
      <title>4. Exercise on local polynomial regression</title>
      <link>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/4_exercises/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mfasiolo.github.io/sc2-2019/rcpp_advanced_i/4_exercises/</guid>
      <description>Smoothing by local polynomial regression References    body { text-align: justify}  Smoothing by local polynomial regression Consider the following data set on solar electricity production from Sidney, Australia:
load(&amp;quot;solarAU.RData&amp;quot;) head(solarAU) ## prod toy tod ## 8832 0.019 0.000000e+00 0 ## 8833 0.032 5.708088e-05 1 ## 8834 0.020 1.141618e-04 2 ## 8835 0.038 1.712427e-04 3 ## 8836 0.036 2.283235e-04 4 ## 8837 0.012 2.854044e-04 5 The variables are:</description>
    </item>
    
    <item>
      <title>4. Exercises on Rcpp</title>
      <link>https://mfasiolo.github.io/sc2-2019/rcpp/4_exercises/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mfasiolo.github.io/sc2-2019/rcpp/4_exercises/</guid>
      <description>Computing the c.d.f. of the Tweedie distribution    body { text-align: justify}  Computing the c.d.f. of the Tweedie distribution Here we consider the Tweedie distribution which includes continuous distributions, such as the normal and gamma, and discrete distributions, such as the Poisson. Its density is \[ p(y|\mu,\phi,p)=a(y,\phi,p)\exp\bigg[\frac{1}{\phi}\{y\theta-\kappa(\theta)\}\bigg], \] where \[ \theta=\frac{\mu^{1-p}}{1-p}\;\;\text{for}\;p\neq1\;\;\;\text{and}\;\;\;\theta=\log\mu\;\;\text{for}\;p=1, \] and \[ \kappa(\theta)=\frac{\mu^{2-p}}{2-p}\;\;\text{for}\;p\neq2\;\;\;\text{and}\;\;\;\theta=\log\mu\;\;\text{for}\;p=2. \] with \(\mu&amp;gt;0\) being the mean, \(\phi&amp;gt;0\) the scale and \(1\leq p\leq2\) is such that \(\text{var}(y)=\mu^{p}\).</description>
    </item>
    
  </channel>
</rss>